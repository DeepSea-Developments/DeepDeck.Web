{"ast":null,"code":"import { throwError as observableThrowError, BehaviorSubject } from 'rxjs';\nimport { take, filter, catchError, switchMap, finalize } from 'rxjs/operators';\nimport { HttpErrorResponse } from '@angular/common/http';\nimport { AuthService } from '../services/auth.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nexport let RequestInterceptor = /*#__PURE__*/(() => {\n  class RequestInterceptor {\n    constructor(injector, router) {\n      this.injector = injector;\n      this.router = router;\n      this.isRefreshingToken = false;\n      this.tokenSubject = new BehaviorSubject(null);\n    }\n\n    addToken(req, token) {\n      return req.clone();\n    }\n\n    intercept(req, next) {\n      const authService = this.injector.get(AuthService);\n      const token = authService.getAccessToken();\n\n      if (token) {\n        return next.handle(this.addToken(req, token)).pipe(catchError(error => {\n          if (error instanceof HttpErrorResponse) {\n            if (error && error.error && error.error.code === 'token_not_valid') {\n              // Handle Access token expired\n              if (error.error.detail === 'Given token not valid for any token type') {\n                return this.handleTokenRefresh(req, next);\n              } // Handle Request token expired\n              else if (error.error.detail === 'Token is invalid or expired') {\n                return this.logoutUser();\n              } else {\n                return observableThrowError(error);\n              }\n            }\n          } else {\n            return observableThrowError(error);\n          }\n        }));\n      } else {\n        return next.handle(req);\n      }\n    }\n\n    handleTokenRefresh(req, next) {\n      if (!this.isRefreshingToken) {\n        this.isRefreshingToken = true; // Reset here so that the following requests wait until the token\n        // comes back from the refreshToken call.\n\n        this.tokenSubject.next(null);\n        const authService = this.injector.get(AuthService);\n        return authService.refreshAccessToken().pipe(switchMap(newToken => {\n          if (newToken) {\n            this.tokenSubject.next(newToken);\n            return next.handle(this.addToken(req, newToken));\n          } // If we don't get a new token, we are in trouble so logout.\n\n\n          return this.logoutUser();\n        }), catchError(error => {\n          // If there is an exception calling 'refreshToken', bad news so logout.\n          return this.logoutUser();\n        }), finalize(() => {\n          this.isRefreshingToken = false;\n        }));\n      } else {\n        return this.tokenSubject.pipe(filter(token => token != null), take(1), switchMap(token => {\n          return next.handle(this.addToken(req, token));\n        }));\n      }\n    }\n\n    logoutUser() {\n      const authService = this.injector.get(AuthService);\n      authService.logout();\n      this.router.navigate(['/auth/login'], {\n        queryParams: {\n          returnUrl: this.router.url\n        }\n      }); // Route to the login page (implementation up to you)\n\n      return observableThrowError('');\n    }\n\n  }\n\n  RequestInterceptor.ɵfac = function RequestInterceptor_Factory(t) {\n    return new (t || RequestInterceptor)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i1.Router));\n  };\n\n  RequestInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: RequestInterceptor,\n    factory: RequestInterceptor.ɵfac\n  });\n  return RequestInterceptor;\n})();","map":null,"metadata":{},"sourceType":"module"}